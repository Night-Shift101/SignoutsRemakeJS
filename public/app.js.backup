class SoldierSignOutApp {
    constructor() {
        this.signouts = [];
        this.filteredSignouts = [];
        this.currentUser = null;
        this.currentSignOutId = null; // For PIN verification
        this.durationInterval = null;
        
        this.initializeElements();
        this.checkAuthentication();
    }

    initializeElements() {
        // User info
        this.userInfo = document.getElementById('userInfo');
        
        // Buttons
        this.refreshBtn = document.getElementById('refreshBtn');
        this.newSignOutBtn = document.getElementById('newSignOutBtn');
        this.logsBtn = document.getElementById('logsBtn');
        this.settingsBtn = document.getElementById('settingsBtn');
        this.logoutBtn = document.getElementById('logoutBtn');
        this.backToDashboard = document.getElementById('backToDashboard');
        this.backToMainBtn = document.getElementById('backToMainBtn');
        
        // Hamburger menu
        this.hamburgerBtn = document.getElementById('hamburgerBtn');
        this.hamburgerMenu = document.querySelector('.hamburger-menu');
        this.hamburgerDropdown = document.getElementById('hamburgerDropdown');
        
        // Views
        this.dashboardView = document.getElementById('dashboardView');
        this.logsView = document.getElementById('logsView');
        this.settingsView = document.getElementById('settingsView');
        
        // Modal elements
        this.signOutModal = document.getElementById('signOutModal');
        this.closeModal = document.getElementById('closeModal');
        this.cancelBtn = document.getElementById('cancelBtn');
        this.signOutForm = document.getElementById('signOutForm');
        
        // Barcode scanning elements
        this.barcodeInput = document.getElementById('barcodeInput');
        this.parseBarcodeBtn = document.getElementById('parseBarcodeBtn');
        this.clearBarcodeBtn = document.getElementById('clearBarcodeBtn');
        this.soldiersChips = document.getElementById('soldiersChips');
        this.clearAllSoldiersBtn = document.getElementById('clearAllSoldiersBtn');
        
        // Store soldiers data
        this.addedSoldiers = [];
        
        // Notification chips container
        this.notificationChips = document.getElementById('notificationChips');
        
        // Background detection for adaptive text
        this.backgroundObserver = null;
        this.initializeBackgroundDetection();
        
        // PIN modal
        this.pinModal = document.getElementById('pinModal');
        this.closePinModal = document.getElementById('closePinModal');
        this.pinInput = document.getElementById('pinInput');
        this.pinSubmit = document.getElementById('pinSubmit');
        this.pinCancel = document.getElementById('pinCancel');
        this.pinError = document.getElementById('pinError');
        this.signInDetails = document.getElementById('signInDetails');
        
        console.log('PIN Modal Elements initialized:');
        console.log('pinModal:', this.pinModal);
        console.log('closePinModal:', this.closePinModal);
        console.log('pinInput:', this.pinInput);
        console.log('pinSubmit:', this.pinSubmit);
        console.log('settingsBtn:', this.settingsBtn);
        
        // Search
        this.searchInput = document.getElementById('searchInput');
        
        // Tables
        this.currentSignOutsTableBody = document.getElementById('currentSignOutsTableBody');
        this.logsTableBody = document.getElementById('logsTableBody');
        this.emptyState = document.getElementById('emptyState');
        this.logsEmptyState = document.getElementById('logsEmptyState');
        
        // Counts
        this.currentlyOutCount = document.getElementById('currentlyOutCount');
        this.totalTodayCount = document.getElementById('totalTodayCount');
        this.totalRecordsCount = document.getElementById('totalRecordsCount');
        
        // Filters
        this.startDate = document.getElementById('startDate');
        this.endDate = document.getElementById('endDate');
        this.soldierNameFilter = document.getElementById('soldierNameFilter');
        this.locationFilter = document.getElementById('locationFilter');
        this.statusFilter = document.getElementById('statusFilter');
        this.applyFiltersBtn = document.getElementById('applyFiltersBtn');
        this.clearFiltersBtn = document.getElementById('clearFiltersBtn');
        this.exportCsvBtn = document.getElementById('exportCsvBtn');
        
        // Settings elements
        this.currentUserDisplay = document.getElementById('currentUserDisplay');
        this.userRoleDisplay = document.getElementById('userRoleDisplay');
        this.maxSignOutDuration = document.getElementById('maxSignOutDuration');
        this.warningThreshold = document.getElementById('warningThreshold');
        this.updateDurationBtn = document.getElementById('updateDurationBtn');
        this.updateWarningBtn = document.getElementById('updateWarningBtn');
        this.exportAllDataBtn = document.getElementById('exportAllDataBtn');
        this.backupDataBtn = document.getElementById('backupDataBtn');
        this.clearOldRecordsBtn = document.getElementById('clearOldRecordsBtn');
        this.resetSystemBtn = document.getElementById('resetSystemBtn');
        
        // Loading overlay
        this.loadingOverlay = document.getElementById('loadingOverlay');
    }

    async checkAuthentication() {
        try {
            console.log('Checking authentication...');
            const response = await fetch('/api/signouts/auth/check', {
                credentials: 'same-origin'
            });
            const result = await response.json();
            console.log('Auth check response:', { status: response.status, result });
            
            if (!result.authenticated) {
                console.log('Not authenticated, redirecting to login...');
                window.location.href = '/login';
                return;
            }
            
            console.log('Authentication successful:', result.user);
            this.currentUser = result.user;
            this.userInfo.textContent = `${result.user.rank} ${result.user.full_name}`;
            this.attachEventListeners();
            this.loadCurrentSignOuts();
            this.startDurationUpdates();
            
        } catch (error) {
            console.error('Authentication check failed:', error);
            window.location.href = '/login';
        }
    }

    attachEventListeners() {
        console.log('Attaching event listeners...');
        console.log('All button elements at attachment time:');
        console.log('- refreshBtn:', this.refreshBtn);
        console.log('- newSignOutBtn:', this.newSignOutBtn);
        console.log('- logsBtn:', this.logsBtn);
        console.log('- settingsBtn:', this.settingsBtn);
        console.log('- logoutBtn:', this.logoutBtn);
        // Button events
        if (this.refreshBtn) {
            this.refreshBtn.addEventListener('click', () => this.loadCurrentSignOuts());
            console.log('Refresh button listener attached');
        }
        if (this.newSignOutBtn) {
            this.newSignOutBtn.addEventListener('click', () => {
                console.log('New Sign-Out button clicked!');
                this.openNewSignOutModal();
            });
            console.log('New Sign-Out button listener attached');
        }
        if (this.logsBtn) {
            this.logsBtn.addEventListener('click', () => this.showLogsView());
            console.log('Logs button listener attached');
        }
        if (this.settingsBtn) {
            this.settingsBtn.addEventListener('click', () => {
                console.log('Settings button clicked - event fired!');
                this.showSettingsWithAuth();
            });
            console.log('Settings button listener attached successfully');
        } else {
            console.error('Settings button not found during event listener attachment!');
        }
        if (this.logoutBtn) {
            this.logoutBtn.addEventListener('click', () => this.logout());
            console.log('Logout button listener attached');
        }
        if (this.backToDashboard) {
            this.backToDashboard.addEventListener('click', () => this.showDashboardView());
            console.log('Back to Dashboard button listener attached');
        }
        if (this.backToMainBtn) {
            this.backToMainBtn.addEventListener('click', () => this.showDashboardView());
            console.log('Back to Main button listener attached');
        }
        
        // Modal events
        this.closeModal.addEventListener('click', () => this.closeNewSignOutModal());
        this.cancelBtn.addEventListener('click', () => this.closeNewSignOutModal());
        this.signOutForm.addEventListener('submit', (e) => this.handleSignOut(e));
        
        // Barcode scanning events
        this.parseBarcodeBtn.addEventListener('click', () => this.handleBarcodeParse());
        this.clearBarcodeBtn.addEventListener('click', () => this.clearBarcodeData());
        this.clearAllSoldiersBtn.addEventListener('click', () => this.clearAllSoldiers());
        this.barcodeInput.addEventListener('paste', () => {
            // Auto-parse after a short delay when data is pasted
            setTimeout(() => this.handleBarcodeParse(), 100);
        });
        
        // PIN modal events
        this.closePinModal.addEventListener('click', () => this.hidePinModal());
        this.pinCancel.addEventListener('click', () => this.hidePinModal());
        this.pinSubmit.addEventListener('click', () => this.handleSignIn());
        this.pinInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.handleSignIn();
        });
        
        // Search
        this.searchInput.addEventListener('input', () => this.filterCurrentSignOuts());
        
        // Filters
        this.applyFiltersBtn.addEventListener('click', () => this.loadFilteredLogs());
        this.clearFiltersBtn.addEventListener('click', () => this.clearFilters());
        this.exportCsvBtn.addEventListener('click', () => this.exportLogs());
        
        // Settings
        if (this.updateDurationBtn) {
            this.updateDurationBtn.addEventListener('click', () => this.updateMaxDuration());
        }
        if (this.updateWarningBtn) {
            this.updateWarningBtn.addEventListener('click', () => this.updateWarningThreshold());
        }
        if (this.exportAllDataBtn) {
            this.exportAllDataBtn.addEventListener('click', () => this.exportAllData());
        }
        if (this.backupDataBtn) {
            this.backupDataBtn.addEventListener('click', () => this.createBackup());
        }
        if (this.clearOldRecordsBtn) {
            this.clearOldRecordsBtn.addEventListener('click', () => this.clearOldRecords());
        }
        if (this.resetSystemBtn) {
            this.resetSystemBtn.addEventListener('click', () => this.resetSystem());
        }
        
        // Hamburger menu events
        if (this.hamburgerBtn) {
            this.hamburgerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.toggleHamburgerMenu();
            });
        }
        
        // Close hamburger menu when clicking outside
        document.addEventListener('click', (e) => {
            if (this.hamburgerMenu && !this.hamburgerMenu.contains(e.target)) {
                this.closeHamburgerMenu();
            }
        });
        
        // Close hamburger menu when clicking dropdown items
        if (this.hamburgerDropdown) {
            this.hamburgerDropdown.addEventListener('click', () => {
                this.closeHamburgerMenu();
            });
        }
        
        // Close modals when clicking outside
        window.addEventListener('click', (e) => {
            if (e.target === this.signOutModal) this.closeNewSignOutModal();
            if (e.target === this.pinModal) this.hidePinModal();
        });
    }

    showLoading(show = true) {
        this.loadingOverlay.style.display = show ? 'flex' : 'none';
    }

    showDashboardView() {
        this.dashboardView.style.display = 'block';
        this.logsView.style.display = 'none';
        this.settingsView.style.display = 'none';
        this.loadCurrentSignOuts();
        this.startDurationUpdates();
    }

    showLogsView() {
        this.dashboardView.style.display = 'none';
        this.logsView.style.display = 'block';
        this.settingsView.style.display = 'none';
        this.stopDurationUpdates();
        this.loadFilteredLogs();
    }

    async loadCurrentSignOuts() {
        try {
            this.showLoading(true);
            const response = await fetch('/api/signouts/current', {
                credentials: 'same-origin'
            });
            
            if (!response.ok) throw new Error('Failed to fetch current sign-outs');
            
            this.signouts = await response.json();
            this.filterCurrentSignOuts();
            this.updateCounts();
        } catch (error) {
            console.error('Error loading current sign-outs:', error);
            this.showNotification('Failed to load current sign-outs', 'error');
        } finally {
            this.showLoading(false);
        }
    }

    async loadAllSignOuts() {
        try {
            const response = await fetch('/api/signouts', {
                credentials: 'same-origin'
            });
            if (!response.ok) throw new Error('Failed to fetch all sign-outs');
            return await response.json();
        } catch (error) {
            console.error('Error loading all sign-outs:', error);
            return [];
        }
    }

    async updateCounts() {
        try {
            const allSignOuts = await this.loadAllSignOuts();
            const today = new Date().toDateString();
            
            this.currentlyOutCount.textContent = this.signouts.length;
            this.totalTodayCount.textContent = allSignOuts.filter(s => 
                new Date(s.sign_out_time).toDateString() === today
            ).length;
            this.totalRecordsCount.textContent = allSignOuts.length;
        } catch (error) {
            console.error('Error updating counts:', error);
        }
    }

    filterCurrentSignOuts() {
        const searchTerm = this.searchInput.value.toLowerCase();
        this.filteredSignouts = this.signouts.filter(signout => 
            signout.soldier_names.toLowerCase().includes(searchTerm) ||
            signout.location.toLowerCase().includes(searchTerm) ||
            signout.signout_id.toLowerCase().includes(searchTerm)
        );
        this.renderCurrentSignOuts();
    }

    renderCurrentSignOuts() {
        const tbody = this.currentSignOutsTableBody;
        const emptyState = this.emptyState;
        
        if (!this.filteredSignouts || this.filteredSignouts.length === 0) {
            tbody.innerHTML = '';
            emptyState.style.display = 'block';
            return;
        }
        
        emptyState.style.display = 'none';
        
        tbody.innerHTML = this.filteredSignouts.map(signout => {
            const duration = this.calculateDuration(signout.sign_out_time);
            const signOutTime = this.formatTime(signout.sign_out_time);
            
            // Calculate minutes for status indication
            const durationMins = Math.floor((new Date() - new Date(signout.sign_out_time)) / (1000 * 60));
            let statusClass = 'status-normal';
            let statusIcon = '●';
            
            if (durationMins > 480) { // 8 hours
                statusClass = 'status-overdue';
                statusIcon = '●';
            } else if (durationMins > 240) { // 4 hours
                statusClass = 'status-warning';
                statusIcon = '●';
            }
            
            return `
                <tr class="signout-row ${statusClass}">
                    <td>
                        <div class="signout-id">
                            <span class="id-badge">${signout.signout_id}</span>
                        </div>
                    </td>
                    <td>
                        ${this.renderSoldierChipsForTable(signout.soldiers, signout.soldier_count)}
                    </td>
                    <td>
                        <div class="location-info">
                            <strong>${signout.location}</strong>
                            ${signout.notes ? `<div class="notes">${signout.notes}</div>` : ''}
                        </div>
                    </td>
                    <td>
                        <div class="time-info">
                            <div class="sign-out-time">${signOutTime}</div>
                        </div>
                    </td>
                    <td>
                        <div class="duration ${statusClass}">${duration}</div>
                    </td>
                    <td>
                        <div class="signed-by">
                            ${signout.signed_out_by_name}
                        </div>
                    </td>
                    <td>
                        <button class="btn btn-secondary btn-sm" onclick="app.promptSignIn('${signout.signout_id}', '${signout.soldier_names}')">
                            Sign In
                        </button>
                    </td>
                </tr>
            `;
        }).join('');
    }

    async loadFilteredLogs() {
        try {
            this.showLoading(true);
            
            const params = new URLSearchParams();
            if (this.startDate.value) params.append('startDate', this.startDate.value);
            if (this.endDate.value) params.append('endDate', this.endDate.value);
            if (this.soldierNameFilter.value) params.append('soldierName', this.soldierNameFilter.value);
            if (this.locationFilter.value) params.append('location', this.locationFilter.value);
            if (this.statusFilter.value) params.append('status', this.statusFilter.value);
            
            const response = await fetch(`/api/signouts/logs?${params}`, {
                credentials: 'same-origin'
            });
            
            if (!response.ok) throw new Error('Failed to fetch logs');
            
            const logs = await response.json();
            this.renderLogsTable(logs);
        } catch (error) {
            console.error('Error loading logs:', error);
            this.showNotification('Failed to load logs', 'error');
        } finally {
            this.showLoading(false);
        }
    }

    renderLogsTable(logs) {
        const tbody = this.logsTableBody;
        const emptyState = this.logsEmptyState;
        
        if (!logs || logs.length === 0) {
            tbody.innerHTML = '';
            emptyState.style.display = 'block';
            return;
        }
        
        emptyState.style.display = 'none';
        
        tbody.innerHTML = logs.map(log => {
            const signOutTime = this.formatTime(log.sign_out_time);
            const signInTime = log.sign_in_time ? this.formatTime(log.sign_in_time) : 'N/A';
            const duration = log.sign_in_time 
                ? this.calculateDuration(log.sign_out_time, log.sign_in_time)
                : this.calculateDuration(log.sign_out_time);
            
            return `
                <tr>
                    <td><span class="id-badge">${log.signout_id}</span></td>
                    <td>
                        ${this.renderSoldierChipsForTable(log.soldiers, log.soldier_count)}
                    </td>
                    <td>${log.location}</td>
                    <td>${signOutTime}</td>
                    <td>${signInTime}</td>
                    <td>${duration}</td>
                    <td>${log.signed_out_by_name}</td>
                    <td>${log.signed_in_by_name || 'N/A'}</td>
                    <td><span class="status-badge status-${log.status.toLowerCase()}">${log.status}</span></td>
                    <td>${log.notes || ''}</td>
                </tr>
            `;
        }).join('');
    }

    clearFilters() {
        this.startDate.value = '';
        this.endDate.value = '';
        this.soldierNameFilter.value = '';
        this.locationFilter.value = '';
        this.statusFilter.value = '';
        this.loadFilteredLogs();
    }

    // Modal management
    openNewSignOutModal() {
        console.log('Opening new sign-out modal...');
        if (this.signOutModal) {
            this.signOutModal.style.display = 'flex';
            // Clear any previous soldiers and render empty state
            this.addedSoldiers = [];
            this.renderSoldierChips();
            // Focus on barcode input
            if (this.barcodeInput) {
                this.barcodeInput.focus();
            }
            
            // Update notification text colors for modal background
            setTimeout(() => {
                this.updateNotificationTextColor();
            }, 100); // Small delay to ensure modal is displayed
            
            console.log('Modal opened successfully');
        } else {
            console.error('Sign-out modal not found!');
        }
    }

    closeNewSignOutModal() {
        this.signOutModal.style.display = 'none';
        this.signOutForm.reset();
        // Clear soldiers list
        this.addedSoldiers = [];
        this.renderSoldierChips();
        
        // Update notification text colors for normal background
        setTimeout(() => {
            this.updateNotificationTextColor();
        }, 100); // Small delay to ensure modal is hidden
    }

    // Sign-out handling
    async handleSignOut(e) {
        e.preventDefault();
        
        // Validate that soldiers have been added
        if (this.addedSoldiers.length === 0) {
            this.showNotification('Please add at least one soldier by scanning their CAC barcode.', 'warning');
            return;
        }
        
        const formData = new FormData(this.signOutForm);
        
        // Prepare soldiers array with individual soldier data
        const soldiers = this.addedSoldiers.map(soldier => ({
            rank: soldier.rank || '',
            firstName: soldier.firstName || '',
            lastName: soldier.lastName || '',
            dodId: soldier.dodId || null
        }));
        
        const signOutData = {
            soldiers: soldiers,
            location: formData.get('location'),
            notes: formData.get('notes'),
            pin: formData.get('pin')
        };
        
        try {
            this.setSubmitLoading(true);
            
            const response = await fetch('/api/signouts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'same-origin',
                body: JSON.stringify(signOutData)
            });
            
            const result = await response.json();
            
            if (response.ok) {
                this.showNotification(`Group signed out successfully: ${result.signout_id}`, 'success');
                this.closeNewSignOutModal();
                this.loadCurrentSignOuts();
            } else {
                this.showNotification(result.error || 'Failed to sign out group', 'error');
            }
        } catch (error) {
            console.error('Error signing out group:', error);
            this.showNotification('Failed to sign out group', 'error');
        } finally {
            this.setSubmitLoading(false);
        }
    }

    // Sign-in handling
    promptSignIn(signOutId, soldierNames) {
        this.currentSignOutId = signOutId;
        this.signInDetails.innerHTML = `
            <div class="sign-in-info">
                <strong>Sign-Out ID:</strong> ${signOutId}<br>
                <strong>Soldiers:</strong> ${soldierNames}
            </div>
        `;
        this.pinModal.style.display = 'flex';
        this.pinInput.focus();
        this.pinError.style.display = 'none';
        
        // Update notification text colors for modal background
        setTimeout(() => {
            this.updateNotificationTextColor();
        }, 100); // Small delay to ensure modal is displayed
    }

    async handleSignIn() {
        const pin = this.pinInput.value;
        if (!pin) {
            this.showPinError('PIN is required');
            return;
        }
        
        // Check if this is for settings access
        const purpose = this.pinModal.dataset.purpose;
        if (purpose === 'settings') {
            await this.handleSettingsAuth(pin);
            return;
        }
        
        try {
            this.setPinLoading(true);
            
            const response = await fetch(`/api/signouts/${this.currentSignOutId}/signin`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'same-origin',
                body: JSON.stringify({ pin })
            });
            
            const result = await response.json();
            
            if (response.ok) {
                this.showNotification('Group signed in successfully', 'success');
                this.hidePinModal();
                this.loadCurrentSignOuts();
            } else {
                this.showPinError(result.error || 'Failed to sign in group');
            }
        } catch (error) {
            console.error('Error signing in group:', error);
            this.showPinError('Failed to sign in group');
        } finally {
            this.setPinLoading(false);
        }
    }

    async handleSettingsAuth(pin) {
        try {
            this.setPinLoading(true);
            
            // Validate PIN with the server
            const response = await fetch('/api/signouts/auth/validate-pin', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'same-origin',
                body: JSON.stringify({ pin })
            });
            
            const result = await response.json();
            
            if (response.ok && result.valid) {
                this.showNotification('Access granted to settings', 'success');
                this.hidePinModal();
                this.showSettingsView();
            } else {
                this.showPinError('Invalid PIN for settings access');
            }
        } catch (error) {
            console.error('Error validating PIN for settings:', error);
            this.showPinError('Failed to validate PIN');
        } finally {
            this.setPinLoading(false);
        }
    }

    hidePinModal() {
        if (!this.pinModal) {
            console.error('PIN modal element not found when trying to hide!');
            return;
        }
        
        this.pinModal.style.display = 'none';
        this.pinModal.style.visibility = 'hidden';
        this.pinModal.style.opacity = '0';
        this.pinModal.classList.remove('show');
        
        if (this.pinInput) {
            this.pinInput.value = '';
        }
        if (this.pinError) {
            this.pinError.style.display = 'none';
        }
        this.currentSignOutId = null;
        
        // Clear the purpose and reset modal title
        delete this.pinModal.dataset.purpose;
        const modalTitle = this.pinModal.querySelector('.modal-header h2');
        if (modalTitle) {
            modalTitle.textContent = 'Enter PIN to Sign In Group';
        }
        
        // Update notification text colors for normal background
        setTimeout(() => {
            this.updateNotificationTextColor();
        }, 100); // Small delay to ensure modal is hidden
    }

    // Export functionality
    async exportLogs() {
        try {
            const params = new URLSearchParams();
            if (this.startDate.value) params.append('startDate', this.startDate.value);
            if (this.endDate.value) params.append('endDate', this.endDate.value);
            if (this.soldierNameFilter.value) params.append('soldierName', this.soldierNameFilter.value);
            if (this.locationFilter.value) params.append('location', this.locationFilter.value);
            if (this.statusFilter.value) params.append('status', this.statusFilter.value);
            
            const response = await fetch(`/api/signouts/logs/export?${params}`, {
                credentials: 'same-origin'
            });
            
            if (!response.ok) throw new Error('Failed to export logs');
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `signout-logs-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            this.showNotification('Logs exported successfully', 'success');
        } catch (error) {
            console.error('Error exporting logs:', error);
            this.showNotification('Failed to export logs', 'error');
        }
    }

    // Logout
    async logout() {
        try {
            await fetch('/api/signouts/auth/logout', { 
                method: 'POST',
                credentials: 'same-origin'
            });
            window.location.href = '/login';
        } catch (error) {
            console.error('Logout error:', error);
            window.location.href = '/login';
        }
    }

    // Duration updates
    startDurationUpdates() {
        this.durationInterval = setInterval(() => {
            if (this.dashboardView.style.display !== 'none') {
                this.renderCurrentSignOuts();
            }
        }, 60000); // Update every minute
    }

    stopDurationUpdates() {
        if (this.durationInterval) {
            clearInterval(this.durationInterval);
            this.durationInterval = null;
        }
    }

    // Barcode scanning methods
    handleBarcodeParse() {
        const barcodeData = this.barcodeInput.value.trim();
        
        if (!barcodeData) {
            this.showNotification('Please enter or paste barcode data first.', 'warning');
            return;
        }

        try {
            const parsedInfo = window.BarcodeParser.parseSoldierInfo(barcodeData);
            
            if (parsedInfo && window.BarcodeParser.validateSoldierInfo(parsedInfo)) {
                // Check if soldier is already added
                const isDuplicate = this.addedSoldiers.some(soldier => 
                    soldier.firstName === parsedInfo.firstName && 
                    soldier.lastName === parsedInfo.lastName &&
                    soldier.dodId === parsedInfo.dodId
                );
                
                if (isDuplicate) {
                    this.showNotification('This soldier has already been added.', 'warning');
                    return;
                }
                
                // Add soldier to the list
                this.addedSoldiers.push(parsedInfo);
                this.renderSoldierChips();
                
                // Show success notification
                this.showNotification(
                    `Successfully added: ${parsedInfo.rank} ${parsedInfo.fullName}`, 
                    'success'
                );
                
                // Clear the barcode input
                this.barcodeInput.value = '';
                
                console.log('Added soldier:', parsedInfo);
            } else {
                this.showNotification('Could not parse soldier information from barcode data. Please check the format.', 'error');
            }
        } catch (error) {
            console.error('Error parsing barcode:', error);
            this.showNotification('Error parsing barcode data. Please try again.', 'error');
        }
    }

    clearBarcodeData() {
        this.barcodeInput.value = '';
        this.showNotification('Barcode data cleared.', 'info');
    }

    renderSoldierChips() {
        if (this.addedSoldiers.length === 0) {
            this.soldiersChips.innerHTML = '<div class="empty-state-chips">No soldiers added yet. Scan CAC barcodes to add soldiers.</div>';
            this.clearAllSoldiersBtn.style.display = 'none';
            this.autoAdjustContainerHeight();
            return;
        }

        this.soldiersChips.innerHTML = this.addedSoldiers.map((soldier, index) => `
            <div class="soldier-chip" data-index="${index}">
                <span class="soldier-chip-name">${soldier.rank} ${soldier.lastName}, ${soldier.firstName}${soldier.middleInitial ? ' ' + soldier.middleInitial + '.' : ''}</span>
                <button class="soldier-chip-remove" onclick="app.removeSoldier(${index})" title="Remove soldier">×</button>
                <div class="soldier-chip-tooltip">DOD ID: ${soldier.dodId || 'N/A'}</div>
            </div>
        `).join('');
        
        this.clearAllSoldiersBtn.style.display = 'inline-block';
        this.autoAdjustContainerHeight();
    }

    // Helper function to render soldier chips for tables
    renderSoldierChipsForTable(soldiers, soldierCount) {
        // If soldiers is still a string (fallback), parse it
        if (typeof soldiers === 'string') {
            if (!soldiers) return '<span class="no-soldiers">No soldiers</span>';
            const soldierNames = soldiers.split(',').map(name => name.trim()).filter(name => name.length > 0);
            soldiers = soldierNames.map(name => ({
                rank: name.split(' ')[0] || '',
                firstName: name.split(' ')[1] || '',
                lastName: name.split(' ').slice(2).join(' ') || '',
                dodId: ''
            }));
        }
        
        // If soldiers is an array but empty
        if (!soldiers || !Array.isArray(soldiers) || soldiers.length === 0) {
            return '<span class="no-soldiers">No soldiers</span>';
        }
        
        // Determine rank category for styling
        const getRankCategory = (rank) => {
            const rankUpper = (rank || '').toUpperCase();
            if (rankUpper.includes('LT') || rankUpper.includes('CPT') || rankUpper.includes('MAJ') || 
                rankUpper.includes('COL') || rankUpper.includes('GEN')) {
                return 'rank-officer';
            } else if (rankUpper.includes('SGT') || rankUpper.includes('CPL') || rankUpper.includes('SFC') || 
                       rankUpper.includes('MSG') || rankUpper.includes('SGM')) {
                return 'rank-nco';
            } else {
                return 'rank-enlisted';
            }
        };
        
        // Show first 4 soldiers as chips
        const maxVisible = 4;
        const chipElements = soldiers.slice(0, maxVisible).map((soldier, index) => {
            const rankCategory = getRankCategory(soldier.rank);
            const displayName = `${soldier.rank || ''} ${soldier.lastName || ''}`.trim();
            const fullName = `${soldier.rank || ''} ${soldier.firstName || ''} ${soldier.lastName || ''}`.trim();
            const tooltipInfo = soldier.dodId ? `${fullName} (DOD: ${soldier.dodId})` : fullName;
            
            return `
                <div class="table-soldier-chip ${rankCategory}">
                    ${displayName}
                    <div class="table-soldier-chip-tooltip">
                        ${tooltipInfo}
                    </div>
                </div>
            `;
        }).join('');
        
        let result = `<div class="table-soldier-chips">${chipElements}`;
        
        // Add "and X more" indicator if there are more soldiers
        if (soldiers.length > maxVisible) {
            const remainingSoldiers = soldiers.slice(maxVisible);
            const remainingNames = remainingSoldiers.map(s => 
                `${s.rank || ''} ${s.firstName || ''} ${s.lastName || ''}`.trim()
            ).join(', ');
            
            result += `
                <div class="table-soldier-chip rank-enlisted">
                    +${soldiers.length - maxVisible} more
                    <div class="table-soldier-chip-tooltip">
                        ${remainingNames}
                    </div>
                </div>
            `;
        }
        
        result += '</div>';
        
        // Add soldier count indicator
        if (soldierCount && soldierCount > 1) {
            result += `
                <div class="soldier-count-indicator">
                    <span class="soldier-count-badge">${soldierCount} soldiers</span>
                </div>
            `;
        }
        
        return result;
    }

    autoAdjustContainerHeight() {
        // Auto-adjust container height based on content
        setTimeout(() => {
            const container = this.soldiersChips;
            const contentHeight = container.scrollHeight;
            const minHeight = 60;
            const maxHeight = 300;
            
            // Calculate optimal height
            const optimalHeight = Math.min(Math.max(contentHeight + 24, minHeight), maxHeight);
            
            // Only adjust if content exceeds current height or is much smaller
            if (contentHeight > container.clientHeight || contentHeight < container.clientHeight - 50) {
                container.style.height = `${optimalHeight}px`;
            }
            
            // Add scroll if content exceeds max height
            if (contentHeight > maxHeight) {
                container.style.overflowY = 'auto';
            } else {
                container.style.overflowY = 'visible';
            }
        }, 100);
    }

    removeSoldier(index) {
        if (index >= 0 && index < this.addedSoldiers.length) {
            const removedSoldier = this.addedSoldiers.splice(index, 1)[0];
            this.renderSoldierChips();
            this.showNotification(`Removed: ${removedSoldier.rank} ${removedSoldier.fullName}`, 'info');
        }
    }

    clearAllSoldiers() {
        this.addedSoldiers = [];
        this.renderSoldierChips();
        this.showNotification('All soldiers cleared.', 'info');
    }

    // Settings management
    showSettingsWithAuth() {
        console.log('showSettingsWithAuth called');
        console.log('pinModal element:', this.pinModal);
        // First check if user needs to authenticate for settings access
        this.requestPinForSettings();
    }

    requestPinForSettings() {
        console.log('requestPinForSettings called');
        console.log('About to show PIN modal:', this.pinModal);
        
        if (!this.pinModal) {
            console.error('PIN modal element not found!');
            this.showNotification('Settings modal not available', 'error');
            return;
        }
        
        // Show PIN modal for settings access
        this.pinModal.style.display = 'flex';
        this.pinModal.style.visibility = 'visible';
        this.pinModal.style.opacity = '1';
        this.pinModal.style.zIndex = '1001';
        this.pinModal.classList.add('show');
        
        console.log('PIN modal display set to flex');
        console.log('PIN modal computed display:', window.getComputedStyle(this.pinModal).display);
        
        if (this.pinInput) {
            this.pinInput.value = '';
            this.pinInput.focus();
        }
        
        if (this.pinError) {
            this.pinError.style.display = 'none';
        }
        
        // Set a flag to indicate this is for settings access
        this.pinModal.dataset.purpose = 'settings';
        console.log('PIN modal purpose set to settings');
        
        // Update modal title
        const modalTitle = this.pinModal.querySelector('.modal-header h2');
        if (modalTitle) {
            modalTitle.textContent = 'Enter PIN for Settings Access';
            console.log('Modal title updated');
        } else {
            console.error('Modal title element not found!');
        }
        
        // Force a repaint
        this.pinModal.offsetHeight;
        
        console.log('PIN modal should now be visible');
    }

    showSettingsView() {
        console.log('showSettingsView called');
        console.log('dashboardView:', this.dashboardView);
        console.log('logsView:', this.logsView);
        console.log('settingsView:', this.settingsView);
        
        if (this.dashboardView) this.dashboardView.style.display = 'none';
        if (this.logsView) this.logsView.style.display = 'none';
        if (this.settingsView) {
            this.settingsView.style.display = 'block';
            console.log('Settings view should now be visible');
        } else {
            console.error('Settings view element not found!');
        }
        this.stopDurationUpdates();
        this.loadSettingsData();
    }

    async loadSettingsData() {
        try {
            // Load current user info
            const currentUser = localStorage.getItem('currentUser');
            if (this.currentUserDisplay) {
                this.currentUserDisplay.textContent = currentUser || 'Unknown User';
            }
            
            // Load system settings from localStorage or defaults
            const maxDuration = localStorage.getItem('maxSignOutDuration') || '8';
            const warningThreshold = localStorage.getItem('warningThreshold') || '4';
            
            if (this.maxSignOutDuration) {
                this.maxSignOutDuration.value = maxDuration;
            }
            if (this.warningThreshold) {
                this.warningThreshold.value = warningThreshold;
            }
            
        } catch (error) {
            console.error('Error loading settings:', error);
            this.showNotification('Failed to load settings data', 'error');
        }
    }

    async updateMaxDuration() {
        try {
            const newDuration = this.maxSignOutDuration.value;
            if (newDuration < 1 || newDuration > 24) {
                this.showNotification('Duration must be between 1 and 24 hours', 'warning');
                return;
            }
            
            localStorage.setItem('maxSignOutDuration', newDuration);
            this.showNotification('Max sign-out duration updated successfully', 'success');
            
            // Add visual feedback
            this.maxSignOutDuration.parentElement.parentElement.classList.add('success');
            setTimeout(() => {
                this.maxSignOutDuration.parentElement.parentElement.classList.remove('success');
            }, 2000);
            
        } catch (error) {
            console.error('Error updating max duration:', error);
            this.showNotification('Failed to update max duration', 'error');
        }
    }

    async updateWarningThreshold() {
        try {
            const newThreshold = this.warningThreshold.value;
            if (newThreshold < 1 || newThreshold > 12) {
                this.showNotification('Warning threshold must be between 1 and 12 hours', 'warning');
                return;
            }
            
            localStorage.setItem('warningThreshold', newThreshold);
            this.showNotification('Warning threshold updated successfully', 'success');
            
            // Add visual feedback
            this.warningThreshold.parentElement.parentElement.classList.add('success');
            setTimeout(() => {
                this.warningThreshold.parentElement.parentElement.classList.remove('success');
            }, 2000);
            
        } catch (error) {
            console.error('Error updating warning threshold:', error);
            this.showNotification('Failed to update warning threshold', 'error');
        }
    }

    async exportAllData() {
        try {
            this.showLoading(true);
            const response = await fetch('/api/signouts/export/all', {
                credentials: 'same-origin'
            });
            
            if (!response.ok) throw new Error('Failed to export data');
            
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `signouts_all_data_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            this.showNotification('All data exported successfully', 'success');
            
        } catch (error) {
            console.error('Error exporting all data:', error);
            this.showNotification('Failed to export all data', 'error');
        } finally {
            this.showLoading(false);
        }
    }

    async createBackup() {
        try {
            this.showLoading(true);
            const response = await fetch('/api/signouts/backup', {
                method: 'POST',
                credentials: 'same-origin'
            });
            
            if (!response.ok) throw new Error('Failed to create backup');
            
            const result = await response.json();
            this.showNotification('Backup created successfully', 'success');
            
        } catch (error) {
            console.error('Error creating backup:', error);
            this.showNotification('Failed to create backup', 'error');
        } finally {
            this.showLoading(false);
        }
    }

    async clearOldRecords() {
        if (!confirm('Are you sure you want to clear all records older than 30 days? This action cannot be undone.')) {
            return;
        }
        
        try {
            this.showLoading(true);
            const response = await fetch('/api/signouts/clear-old', {
                method: 'DELETE',
                credentials: 'same-origin'
            });
            
            if (!response.ok) throw new Error('Failed to clear old records');
            
            const result = await response.json();
            this.showNotification(`Cleared ${result.deletedCount} old records`, 'success');
            
        } catch (error) {
            console.error('Error clearing old records:', error);
            this.showNotification('Failed to clear old records', 'error');
        } finally {
            this.showLoading(false);
        }
    }

    async resetSystem() {
        if (!confirm('Are you sure you want to reset the entire system? This will delete ALL data and cannot be undone.')) {
            return;
        }
        
        if (!confirm('This is your final warning. All sign-out data will be permanently deleted. Continue?')) {
            return;
        }
        
        try {
            this.showLoading(true);
            const response = await fetch('/api/signouts/reset-system', {
                method: 'DELETE',
                credentials: 'same-origin'
            });
            
            if (!response.ok) throw new Error('Failed to reset system');
            
            this.showNotification('System reset successfully', 'success');
            
            // Clear localStorage
            localStorage.clear();
            
            // Redirect to login after a delay
            setTimeout(() => {
                window.location.href = '/login';
            }, 2000);
            
        } catch (error) {
            console.error('Error resetting system:', error);
            this.showNotification('Failed to reset system', 'error');
        } finally {
            this.showLoading(false);
        }
    }
    
    // Utility functions
    calculateDuration(startTime, endTime = null) {
        const start = new Date(startTime);
        const end = endTime ? new Date(endTime) : new Date();
        const diffMs = end - start;
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const hours = Math.floor(diffMins / 60);
        const minutes = diffMins % 60;
        
        if (hours > 0) {
            return `${hours}h ${minutes}m`;
        } else {
            return `${minutes}m`;
        }
    }

    formatTime(dateString) {
        const date = new Date(dateString);
        return date.toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        });
    }

    // UI helpers
    setSubmitLoading(loading) {
        const submitBtn = this.signOutForm.querySelector('button[type="submit"]');
        const btnText = submitBtn.querySelector('.btn-text');
        const loader = submitBtn.querySelector('.btn-loader');
        
        submitBtn.disabled = loading;
        btnText.style.display = loading ? 'none' : 'inline';
        loader.style.display = loading ? 'inline-block' : 'none';
    }

    setPinLoading(loading) {
        const btnText = this.pinSubmit.querySelector('.btn-text');
        const loader = this.pinSubmit.querySelector('.btn-loader');
        
        this.pinSubmit.disabled = loading;
        btnText.style.display = loading ? 'none' : 'inline';
        loader.style.display = loading ? 'inline-block' : 'none';
    }

    showPinError(message) {
        this.pinError.textContent = message;
        this.pinError.style.display = 'block';
    }

    // Notification system - Using top notification chips
    showNotification(message, type = 'info') {
        const notificationChip = document.createElement('div');
        notificationChip.className = `notification-chip ${type}`;
        
        // Icon based on type
        const iconMap = {
            'success': '✓',
            'error': '✗',
            'warning': '!',
            'info': 'i'
        };
        
        notificationChip.innerHTML = `
            <div class="notification-chip-icon">${iconMap[type] || iconMap.info}</div>
            <div class="notification-chip-content">${message}</div>
            <button class="notification-chip-close" title="Close">&times;</button>
        `;
        
        // Apply adaptive text color based on current background
        const backgroundColor = this.detectBackgroundColor();
        notificationChip.classList.add(backgroundColor);
        
        this.notificationChips.appendChild(notificationChip);
        
        // Auto hide after 5 seconds
        const autoHideTimer = setTimeout(() => {
            this.hideNotificationChip(notificationChip);
        }, 5000);
        
        // Close button event
        notificationChip.querySelector('.notification-chip-close').addEventListener('click', () => {
            clearTimeout(autoHideTimer);
            this.hideNotificationChip(notificationChip);
        });
        
        // Remove old notifications if too many
        const chips = this.notificationChips.querySelectorAll('.notification-chip');
        if (chips.length > 5) {
            this.hideNotificationChip(chips[0]);
        }
    }

    hideNotificationChip(chip) {
        chip.style.animation = 'slideOutToTop 0.3s ease-in';
        setTimeout(() => {
            if (chip.parentNode) {
                chip.parentNode.removeChild(chip);
            }
        }, 300);
    }

    initializeBackgroundDetection() {
        // Initialize mutation observer to detect when modals open/close
        this.backgroundObserver = new MutationObserver(() => {
            this.updateNotificationTextColor();
        });
        
        // Observe changes to modal visibility
        const modals = document.querySelectorAll('.modal');
        modals.forEach(modal => {
            this.backgroundObserver.observe(modal, {
                attributes: true,
                attributeFilter: ['class', 'style']
            });
        });
        
        // Also observe body class changes
        this.backgroundObserver.observe(document.body, {
            attributes: true,
            attributeFilter: ['class']
        });
        
        // Initial color update
        this.updateNotificationTextColor();
    }

    updateNotificationTextColor() {
        const notifications = this.notificationChips.querySelectorAll('.notification-chip');
        const backgroundColor = this.detectBackgroundColor();
        
        notifications.forEach(notification => {
            // Remove existing background classes
            notification.classList.remove('light-background', 'dark-background');
            
            // Add appropriate class based on detected background
            notification.classList.add(backgroundColor);
        });
    }

    detectBackgroundColor() {
        // Check if any modal is currently visible
        const signOutModalVisible = this.signOutModal && 
            (this.signOutModal.style.display === 'flex' || 
             window.getComputedStyle(this.signOutModal).display === 'flex');
        
        const pinModalVisible = this.pinModal && 
            (this.pinModal.style.display === 'flex' || 
             window.getComputedStyle(this.pinModal).display === 'flex');
        
        if (signOutModalVisible || pinModalVisible) {
            // Modal overlay creates a dark backdrop
            return 'dark-background';
        } else {
            // Main background is the gradient
            return 'light-background';
        }
    }

    getElementBackgroundLuminance(element) {
        // Get computed background color
        const computedStyle = window.getComputedStyle(element);
        let backgroundColor = computedStyle.backgroundColor;
        
        // If background is transparent, check parent elements
        let currentElement = element;
        while (backgroundColor === 'rgba(0, 0, 0, 0)' || backgroundColor === 'transparent') {
            currentElement = currentElement.parentElement;
            if (!currentElement || currentElement === document.body) {
                // Default to body background
                backgroundColor = window.getComputedStyle(document.body).backgroundColor;
                break;
            }
            backgroundColor = window.getComputedStyle(currentElement).backgroundColor;
        }
        
        // Parse RGB values
        const rgbMatch = backgroundColor.match(/\d+/g);
        if (!rgbMatch || rgbMatch.length < 3) {
            return 0.5; // Default to medium luminance
        }
        
        const [r, g, b] = rgbMatch.map(Number);
        
        // Calculate relative luminance using WCAG formula
        const sR = r / 255;
        const sG = g / 255;
        const sB = b / 255;
        
        const rLinear = sR <= 0.03928 ? sR / 12.92 : Math.pow((sR + 0.055) / 1.055, 2.4);
        const gLinear = sG <= 0.03928 ? sG / 12.92 : Math.pow((sG + 0.055) / 1.055, 2.4);
        const bLinear = sB <= 0.03928 ? sB / 12.92 : Math.pow((sB + 0.055) / 1.055, 2.4);
        
        return 0.2126 * rLinear + 0.7152 * gLinear + 0.0722 * bLinear;
    }

    // Hamburger Menu Management
    toggleHamburgerMenu() {
        if (this.hamburgerMenu && this.hamburgerMenu.classList.contains('active')) {
            this.closeHamburgerMenu();
        } else {
            this.openHamburgerMenu();
        }
    }

    openHamburgerMenu() {
        if (this.hamburgerMenu) {
            this.hamburgerMenu.classList.add('active');
        }
    }

    closeHamburgerMenu() {
        if (this.hamburgerMenu) {
            this.hamburgerMenu.classList.remove('active');
        }
    }

    // Test function for debugging settings functionality
    testSettingsModal() {
        console.log('=== SETTINGS MODAL DEBUG TEST ===');
        console.log('pinModal element:', this.pinModal);
        console.log('pinModal current display:', this.pinModal ? this.pinModal.style.display : 'Element not found');
        console.log('pinModal computed display:', this.pinModal ? window.getComputedStyle(this.pinModal).display : 'Element not found');
        
        if (this.pinModal) {
            console.log('Attempting to show PIN modal...');
            this.pinModal.style.display = 'flex';
            this.pinModal.style.zIndex = '1001';
            console.log('PIN modal display after setting to flex:', this.pinModal.style.display);
            console.log('PIN modal computed display after setting:', window.getComputedStyle(this.pinModal).display);
            
            // Try adding the show class as well
            this.pinModal.classList.add('show');
            console.log('Added show class to modal');
            
            // Check if modal is visible in viewport
            const rect = this.pinModal.getBoundingClientRect();
            console.log('Modal position and size:', rect);
            console.log('Modal visibility check:', {
                offsetParent: this.pinModal.offsetParent,
                offsetHeight: this.pinModal.offsetHeight,
                offsetWidth: this.pinModal.offsetWidth
            });
        }
        
        console.log('=== END DEBUG TEST ===');
    }
}

// Initialize the app when the page loads
let app;
document.addEventListener('DOMContentLoaded', () => {
    app = new SoldierSignOutApp();
    
    // Add global test function for debugging
    window.testSettings = () => {
        if (app) {
            app.testSettingsModal();
        } else {
            console.error('App not initialized');
        }
    };
    
    window.forceShowPinModal = () => {
        if (app && app.pinModal) {
            app.requestPinForSettings();
        } else {
            console.error('App or PIN modal not available');
        }
    };
});
